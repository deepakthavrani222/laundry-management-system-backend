const mongoose = require('mongoose');

const BannerSchema = new mongoose.Schema({
  // Ownership
  tenancy: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'Tenancy', 
    required: function() { return this.bannerScope === 'TENANT'; }
  },
  bannerScope: { 
    type: String, 
    enum: ['TENANT', 'GLOBAL'], 
    required: true,
    default: 'TENANT'
  },
  
  // Template Reference
  template: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'BannerTemplate',
    required: true
  },
  templateType: {
    type: String,
    enum: ['HERO', 'SLIDER', 'STRIP', 'CARD', 'MODAL', 'FLOATING'],
    required: true
  },
  
  // Position (from template's allowed positions)
  position: {
    type: String,
    enum: [
      'HOME_HERO_TOP', 'HOME_SLIDER_MID', 'HOME_STRIP_TOP', 'HOME_STRIP_BOTTOM', 'HOME_CARD_SIDEBAR',
      'SERVICES_HERO_TOP', 'SERVICES_SLIDER_MID', 'SERVICES_CARD_GRID',
      'OFFERS_HERO_TOP', 'OFFERS_SLIDER_MID', 'OFFERS_CARD_GRID',
      'CHECKOUT_STRIP_TOP', 'CHECKOUT_CARD_SIDEBAR',
      'DASHBOARD_HERO_TOP', 'DASHBOARD_CARD_GRID',
      'LOGIN_HERO_SIDE', 'LOGIN_STRIP_TOP',
      'GLOBAL_STRIP_TOP', 'GLOBAL_MODAL_CENTER', 'GLOBAL_FLOATING_CORNER'
    ],
    required: true
  },
  
  // Content (filled by admin based on template fields)
  content: {
    title: { 
      type: String, 
      required: true, 
      maxlength: 100,
      trim: true
    },
    subtitle: { 
      type: String, 
      maxlength: 150,
      trim: true
    },
    description: { 
      type: String, 
      maxlength: 500,
      trim: true
    },
    message: {
      type: String,
      maxlength: 200,
      trim: true
    },
    customFields: mongoose.Schema.Types.Mixed // For template-specific fields
  },
  
  // Visual Content
  imageUrl: { 
    type: String, 
    required: false  // Optional - can use placeholder or no image
  },
  imageAlt: { 
    type: String,
    default: 'Banner Image'
  },
  mobileImageUrl: { 
    type: String 
  }, // Optional mobile-specific image
  
  // Promotional Feature Linking (Optional - not all banners need promotions)
  linkedPromotion: {
    type: {
      type: String,
      enum: ['campaign', 'discount', 'coupon', 'referral', 'loyalty', 'none'],
      default: 'none'
    },
    id: {
      type: mongoose.Schema.Types.ObjectId,
      refPath: 'linkedPromotion.type'
    }
  },
  
  // Legacy field for backward compatibility
  linkedCampaign: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Campaign',
    required: false
  },
  
  // Call to Action
  cta: {
    text: { 
      type: String, 
      maxlength: 50,
      default: 'Learn More'
    },
    link: { 
      type: String 
    }, // Internal link or external URL
    secondaryText: {
      type: String,
      maxlength: 50
    },
    secondaryLink: {
      type: String
    }
  },
  
  // Display Settings - Removed targetPages (replaced by position)
  priority: { 
    type: Number, 
    default: 0,
    min: 0,
    max: 100
  }, // Higher = shown first
  
  // Scheduling
  schedule: {
    startDate: { 
      type: Date, 
      required: true,
      default: Date.now
    },
    endDate: { 
      type: Date, 
      required: true 
    },
    autoActivate: {
      type: Boolean,
      default: true
    },
    autoComplete: {
      type: Boolean,
      default: true
    }
  },
  
  // Lifecycle State
  state: {
    type: String,
    enum: ['DRAFT', 'PENDING_APPROVAL', 'APPROVED', 'REJECTED', 'SCHEDULED', 'ACTIVE', 'PAUSED', 'COMPLETED'],
    default: 'DRAFT'
  },
  
  // Approval Workflow
  approval: {
    required: { 
      type: Boolean, 
      default: function() {
        return this.bannerScope === 'TENANT';
      }
    },
    status: {
      type: String,
      enum: ['PENDING', 'APPROVED', 'REJECTED'],
      default: 'PENDING'
    },
    approvedBy: { 
      type: mongoose.Schema.Types.ObjectId, 
      ref: 'User'
    },
    approvedAt: { 
      type: Date 
    },
    rejectedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    rejectedAt: {
      type: Date
    },
    rejectionReason: { 
      type: String,
      maxlength: 500
    }
  },
  
  // Analytics
  analytics: {
    impressions: { 
      type: Number, 
      default: 0,
      min: 0
    },
    clicks: { 
      type: Number, 
      default: 0,
      min: 0
    },
    conversions: { 
      type: Number, 
      default: 0,
      min: 0
    }, // Orders from banner
    revenue: { 
      type: Number, 
      default: 0,
      min: 0
    }
  },
  
  // Metadata
  autoGenerated: {
    type: Boolean,
    default: false
  },
  isActive: { 
    type: Boolean, 
    default: true 
  },
  createdBy: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'User',
    required: true
  },
  updatedBy: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'User'
  }
}, { 
  timestamps: true 
});

// Indexes for performance
BannerSchema.index({ tenancy: 1, state: 1, 'schedule.startDate': 1, 'schedule.endDate': 1 });
BannerSchema.index({ bannerScope: 1, state: 1 });
BannerSchema.index({ priority: -1 });
BannerSchema.index({ position: 1, state: 1 });
BannerSchema.index({ 'schedule.startDate': 1, 'schedule.endDate': 1 });
BannerSchema.index({ template: 1 });
BannerSchema.index({ linkedCampaign: 1 });
BannerSchema.index({ 'linkedPromotion.type': 1, 'linkedPromotion.id': 1 });
BannerSchema.index({ 'approval.status': 1 });

// Virtual for CTR (Click-Through Rate)
BannerSchema.virtual('ctr').get(function() {
  if (this.analytics.impressions === 0) return 0;
  return ((this.analytics.clicks / this.analytics.impressions) * 100).toFixed(2);
});

// Virtual for Conversion Rate
BannerSchema.virtual('conversionRate').get(function() {
  if (this.analytics.clicks === 0) return 0;
  return ((this.analytics.conversions / this.analytics.clicks) * 100).toFixed(2);
});

// Methods
BannerSchema.methods.isValid = function() {
  const now = new Date();
  return this.state === 'ACTIVE' && 
         this.isActive && 
         this.schedule.startDate <= now && 
         this.schedule.endDate >= now;
};

BannerSchema.methods.canDisplay = function(position) {
  if (!this.isValid()) return false;
  return this.position === position;
};

BannerSchema.methods.recordImpression = async function() {
  this.analytics.impressions += 1;
  await this.save();
  return this.analytics.impressions;
};

BannerSchema.methods.recordClick = async function() {
  this.analytics.clicks += 1;
  await this.save();
  return this.analytics.clicks;
};

BannerSchema.methods.recordConversion = async function(orderValue = 0) {
  this.analytics.conversions += 1;
  this.analytics.revenue += orderValue;
  await this.save();
  return {
    conversions: this.analytics.conversions,
    revenue: this.analytics.revenue
  };
};

BannerSchema.methods.transitionState = async function(newState, userId = null) {
  const validTransitions = {
    DRAFT: ['PENDING_APPROVAL'],
    PENDING_APPROVAL: ['APPROVED', 'REJECTED'],
    APPROVED: ['SCHEDULED', 'ACTIVE'],
    REJECTED: ['DRAFT'],
    SCHEDULED: ['ACTIVE', 'PAUSED'],
    ACTIVE: ['PAUSED', 'COMPLETED'],
    PAUSED: ['ACTIVE', 'COMPLETED'],
    COMPLETED: []
  };
  
  if (!validTransitions[this.state].includes(newState)) {
    throw new Error(`Invalid state transition from ${this.state} to ${newState}`);
  }
  
  this.state = newState;
  
  // Handle approval state changes
  if (newState === 'APPROVED') {
    this.approval.status = 'APPROVED';
    this.approval.approvedBy = userId;
    this.approval.approvedAt = new Date();
  } else if (newState === 'REJECTED') {
    this.approval.status = 'REJECTED';
    this.approval.rejectedBy = userId;
    this.approval.rejectedAt = new Date();
  }
  
  if (userId) {
    this.updatedBy = userId;
  }
  
  await this.save();
  return this;
};

// Static methods
BannerSchema.statics.getActiveBannersByPosition = async function(position, tenancyId = null) {
  const now = new Date();
  
  const query = {
    position,
    state: 'ACTIVE',
    isActive: true,
    'schedule.startDate': { $lte: now },
    'schedule.endDate': { $gte: now }
  };
  
  // If position is GLOBAL, only get global banners
  if (position.startsWith('GLOBAL_')) {
    query.bannerScope = 'GLOBAL';
  } else if (tenancyId) {
    // Get both tenant and global banners for this position
    query.$or = [
      { tenancy: tenancyId, bannerScope: 'TENANT' },
      { bannerScope: 'GLOBAL' }
    ];
  }
  
  const banners = await this.find(query)
    .populate('template')
    .populate('linkedCampaign')
    .sort({ priority: -1, createdAt: -1 });
  
  return banners;
};

BannerSchema.statics.getPendingApprovalBanners = async function() {
  return this.find({
    state: 'PENDING_APPROVAL',
    'approval.status': 'PENDING'
  })
    .populate('template')
    .populate('linkedCampaign')
    .populate('tenancy')
    .populate('createdBy', 'name email')
    .sort({ createdAt: -1 });
};

BannerSchema.statics.getBannersByState = async function(state, tenancyId = null) {
  const query = { state };
  if (tenancyId) {
    query.tenancy = tenancyId;
  }
  
  return this.find(query)
    .populate('template')
    .populate('linkedCampaign')
    .sort({ createdAt: -1 });
};

// Pre-save middleware
BannerSchema.pre('save', function(next) {
  // Set approval requirement for tenant banners
  if (this.isNew && this.bannerScope === 'TENANT') {
    this.approval.required = true;
    if (this.state === 'DRAFT') {
      // Don't auto-transition to pending, let admin explicitly submit
    }
  }
  
  // Auto-complete if end date passed
  const now = new Date();
  if (this.schedule.endDate < now && this.state === 'ACTIVE' && this.schedule.autoComplete) {
    this.state = 'COMPLETED';
  }
  
  // Auto-activate if start date reached and approved
  if (this.schedule.startDate <= now && 
      this.schedule.endDate >= now && 
      this.state === 'SCHEDULED' && 
      this.schedule.autoActivate) {
    this.state = 'ACTIVE';
  }
  
  next();
});

// Ensure virtuals are included in JSON
BannerSchema.set('toJSON', { virtuals: true });
BannerSchema.set('toObject', { virtuals: true });

module.exports = mongoose.model('Banner', BannerSchema);
